(ns code-katas-2.core)

(defn unpartial
  "Escribir una funcion que acepte una funcion parcial con cantidad de argumentos desconocida,
retornar una funcion equivalente de n argumentos"
  [f]
  (fn [& args]
      (loop [ funcion f argumentos args ]
       (if (fn? funcion)
         (recur (funcion (first argumentos)) (rest argumentos))
         funcion
         ))
      )
  
)
  
(println((unpartial (fn [a]
                            (fn [b]
                              (fn [c]
                                (fn [d]
                                  (+ a b c d)))))) 10 5 3 2))

(defn search
  "Dado un numero cualquiera de secuencias, cada una ya ordenada de menor a mayor, encontrar el numero
mas chico que aparezca en todas las secuencias, las secuencias pueden ser infinitas."
  [& seqs]
  
  (loop [sec seqs]
    (if (apply =(map first sec))
      (first(first sec))
      (let [primero (first (sort(map first sec)))]
      (recur (quitar (buscarParaQuitar primero sec) sec))))))
  
        

(println(search [2 9 40 90] [1 3 4 5 6 40]))





(defn quitar
  [lista secuencia]
  (lazy-seq
  (if (> (count secuencia) 0)
    (if (= (first secuencia) lista)
     ; (conj (quitar lista (rest secuencia)) (rest lista))
     ; (conj(quitar lista (rest secuencia)) (first secuencia))
     (cons (rest lista) (quitar lista (rest secuencia)) )
     (cons (first secuencia)(quitar lista (rest secuencia)))
            )
    ()))
  )

(defn buscarParaQuitar
     [numero  seqs]
     (lazy-seq
    (if (> (count seqs) 0)
       (if (= (first(first seqs)) numero)
         (first seqs)
         (buscarParaQuitar numero (rest seqs)))
       seqs))
    )

(defn intercalar
  "Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y
retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos
que cumplan el predicado"
  [predicado valor secuencia]
  
    (lazy-seq
    (if (> (count secuencia) 1)
      (if (predicado (first secuencia) (second secuencia))
         (conj  (intercalar predicado valor (rest secuencia)) valor (first secuencia) )
         (conj  (intercalar predicado valor (rest secuencia)) (first secuencia))
         )
    secuencia))
)
    
(println(intercalar < :menor [2 3 4 5 6 7 ]))
  

(defn tartamudeo
  "Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.
Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].
La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde
cada nuevo elemento es el elemento anterior comprimido."
  [secuencia]
  (next (iterate sucesion-tartamudeo secuencia))
)

(defn sucesion-tartamudeo
  [secuencia]
  (lazy-seq
    (if-not (empty? secuencia)
   
      (concat (tarta (repetidos secuencia)) (sucesion-tartamudeo (drop (count (repetidos secuencia)) secuencia)))
      secuencia
)))



(defn repetidos
  [vector]
 
(if (>(count (rest vector))0)


    (loop [v vector acc []]
      (def res (conj acc (first v)))
      (if (= (first v) (first (rest v)))
        (recur (rest v) res)
        (conj acc (first v))))

    [(first vector)]
))


(defn tarta
  [vector]
  (let
    [losRepetidos (count vector)
     primer (first vector)
     pares (conj [] losRepetidos primer)]
    pares))
     


  (println(take 10(tartamudeo [1])))
